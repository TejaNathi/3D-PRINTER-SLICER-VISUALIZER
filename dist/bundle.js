/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var https_cdn_jsdelivr_net_npm_three_0_120_1_examples_jsm_loaders_STLLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! https://cdn.jsdelivr.net/npm/three@0.120.1/examples/jsm/loaders/STLLoader.js */ \"https://cdn.jsdelivr.net/npm/three@0.120.1/examples/jsm/loaders/STLLoader.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([https_cdn_jsdelivr_net_npm_three_0_120_1_examples_jsm_loaders_STLLoader_js__WEBPACK_IMPORTED_MODULE_0__]);\nhttps_cdn_jsdelivr_net_npm_three_0_120_1_examples_jsm_loaders_STLLoader_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n//import { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js';\n\n// Create scene\n//import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.120.1/build/three.module.js';\n\n\n//import { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nvar loader = new https_cdn_jsdelivr_net_npm_three_0_120_1_examples_jsm_loaders_STLLoader_js__WEBPACK_IMPORTED_MODULE_0__.STLLoader();\nvar scene = new THREE.Scene();\nvar camera = new THREE.PerspectiveCamera(30, innerWidth / innerHeight);\ncamera.position.set(0, 10, 100);\ncamera.lookAt(scene.position);\nvar renderer = new THREE.WebGLRenderer({\n  antialias: true\n});\nrenderer.setSize(innerWidth, innerHeight);\ndocument.body.appendChild(renderer.domElement);\n// Add a plane to the scene\nvar planeGeometry = new THREE.PlaneGeometry(100, 100, 10, 10);\nvar planeMaterial = new THREE.MeshBasicMaterial({\n  color: 0x00ff00,\n  side: THREE.DoubleSide,\n  wireframe: true\n});\nvar plane = new THREE.Mesh(planeGeometry, planeMaterial);\nplane.rotation.x = Math.PI / 2; // Rotate the plane to be horizontal\nplane.position.y = 0; // Adjust the position of the plane\nscene.add(plane);\nvar faceIndex = 0; // You can change this index based on your requirements\nvar faceNormal = new THREE.Vector3();\nplaneGeometry.faces[faceIndex].normal.clone(faceNormal);\nvar constantPlaneNormal = new THREE.Vector3(0, -1, 0);\n// const materialFront = new THREE.MeshBasicMaterial({ color: 0xff0000  }); // Red\n// const materialBack = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green\n// const materialTop = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue\n// const materialBottom = new THREE.MeshBasicMaterial({ color: 0xffff00}); // Yellow\n// const materialLeft = new THREE.MeshBasicMaterial({ color: 0xff00ff }); // Magenta\n// const materialRight = new THREE.MeshBasicMaterial({ color: 0x00ffff}); // Cyan\n\n// // Create a MultiMaterial by combining the materials\n// const multiMaterial = new THREE.MultiMaterial([\n//     materialFront,\n//     materialBack,\n//     materialTop,\n//     materialBottom,\n//     materialLeft,\n//     materialRight\n// ]);\n\n// //var controls = new THREE.OrbitControls( camera, renderer.domElement );\nvar controls = new THREE.OrbitControls(camera, renderer.domElement);\ncontrols.enableDamping = true;\n// // Create a cube geometry\n// const geometry = new THREE.BoxBufferGeometry(10, 30, 10);\n// const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n// const cube = new THREE.Mesh(geometry, multiMaterial);\n// scene.add(cube);\n\n// const bufferGeometry =cube.geometry;\n// bufferGeometry.computeFaceNormals();\n\n// // Compute vertex normals\n// bufferGeometry.computeVertexNormals();\n\n// // Log the normals of the cube\n// // function normalsupdates(cubegeomerty){\n// //     const faces =cubegeomerty.attributes.normal.Array;\n\n// // // Array to store normals\n// // const normals = [];\n\n// // // Iterate through the faces and get the normals\n// // for (let i = 0; i < faces.length; i++) {\n// //     normals.push(faces[i].normal);\n// // }\n// // console.log(\"normals\",normals);\n// // }\n\n// function findUpFaces(geometry, threshold = 0.1) {\n//     const upFaces = [];\n\n//     // Iterate through faces to find those with normals approximately matching (0, 1, 0)\n//     for (let i = 0; i < geometry.faces.length; i++) {\n//         const faceNormal = geometry.faces[i].normal;\n//         if (Math.abs(faceNormal.x) < threshold && faceNormal.y > 1 - threshold && Math.abs(faceNormal.z) < threshold) {\n//             upFaces.push(i);\n//         }\n//     }\n\n//     return upFaces;\n// }\n// function getFaceNormals(geometry, faceIndex) {\n//     const normals = geometry.attributes.normal.array;\n//     const startIndex = faceIndex * 6;  // Corrected indexing for BufferGeometry\n\n//     // For a BufferGeometry, each normal is represented by three components (x, y, z)\n//     const normal = new THREE.Vector3( normals[startIndex],normals[startIndex + 1], normals[startIndex + 2]);\n\n//     // Assuming y is up, no need to switch y and z components\n//     return normal;\n// }\n\n// let xAxisLine, yAxisLine, zAxisLine;\n// function createAxesLines(mesh) {\n//     // Extract the columns of the mesh matrix (local coordinate axes)\n//     const xAxis = new THREE.Vector3().fromArray(mesh.matrix.elements.slice(0, 3));\n//     const yAxis = new THREE.Vector3().fromArray(mesh.matrix.elements.slice(4, 7));\n//     const zAxis = new THREE.Vector3().fromArray(mesh.matrix.elements.slice(8, 11));\n\n//     // Remove existing lines if they exist\n//     if (xAxisLine) scene.remove(xAxisLine);\n//     if (yAxisLine) scene.remove(yAxisLine);\n//     if (zAxisLine) scene.remove(zAxisLine);\n\n//     // Create lines along the local coordinate axes\n//     xAxisLine = new THREE.ArrowHelper(xAxis, mesh.position, 20, 0xff0000);\n//     yAxisLine = new THREE.ArrowHelper(yAxis, mesh.position, 20, 0x00ff00);\n//     zAxisLine = new THREE.ArrowHelper(zAxis, mesh.position, 20, 0x0000ff);\n\n//     // Add the lines to the scene\n//     scene.add(xAxisLine);\n//     scene.add(yAxisLine);\n//     scene.add(zAxisLine);\n// }\n// createAxesLines(cube)\n\n// function updateNormalsAfterRotation(cube) {\n//     // Assuming three components (x, y, z) per normal\n//     const normals = cube.geometry.attributes.normal.array;\n\n//     // Iterate through each face of the cube\n//     for (let i = 0; i < normals.length; i += 3) { // Updated the increment to 3\n//         const normal = new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]);\n\n//         // Apply quaternion to the normal\n//         normal.applyQuaternion(cube.quaternion);\n\n//         // Update the normal values in the buffer\n//         normals[i] = normal.x;\n//         normals[i + 1] = normal.y;\n//         normals[i + 2] = normal.z;\n//     }\n\n//     // Notify Three.js that normals are updated\n//     cube.geometry.attributes.normal.needsUpdate = true;\n//     cube.updateMatrixWorld();\n// }\n\n// function getFaceIndexWithNormal(cube, threshold = 0.01) {\n//     const normals = cube.geometry.attributes.normal.array;\n//     const quaternion = cube.quaternion.clone();\n\n//     // Transform the target normal {0, 1, 0} using the quaternion\n//     const targetNormal = new THREE.Vector3(0, -1, 0).applyQuaternion(quaternion);\n\n//     // Find the face index with the closest normal to the transformed target normal\n//     let closestFaceIndex = -1;\n//     let minAngle = Infinity;\n\n//     for (let i = 0; i < normals.length; i += 3) {\n//         const normal = new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]);\n\n//         // Apply quaternion to the normal\n//         normal.applyQuaternion(quaternion);\n\n//         // Calculate the angle between the target normal and the current normal\n//         const angle = targetNormal.angleTo(normal);\n\n//         // Update the closest face index if the current angle is smaller and within the threshold\n//         if (angle < minAngle && angle < threshold) {\n//             minAngle = angle;\n//             closestFaceIndex = i / 9; // Convert index to face index\n//         }\n//     }\n\n//     return closestFaceIndex;\n// }\n\n// console.log(\"buffer\",bufferGeometry);\n// //normalsupdates(bufferGeometry);\n\n// // Assuming you have a mesh with BufferGeometry\n\n// // Check if the geometry is BufferGeometry and has the position attribute\n// if (bufferGeometry.isBufferGeometry && bufferGeometry.attributes) {\n//     const positionAttribute = bufferGeometry.attributes.position;\n//     const positionArray = positionAttribute.array;\n\n//     // Assuming the item size is 3 (common for position)\n//     const itemSize = positionAttribute.itemSize;\n\n//     // Access individual components of the position attribute\n//     for (let i = 0; i < positionAttribute.count; i++) {\n//         const xPos = positionArray[i * itemSize];\n//         const yPos = positionArray[i * itemSize + 1];\n//         const zPos = positionArray[i * itemSize + 2];\n\n//         // Do something with the individual components...\n//     }\n// } else {\n//     console.error(\"Position attribute not found in BufferGeometry.\");\n// }\n\n// let isDragging = false;\n// let previousMouseX = 0;\n\n// // Event listeners for mouse move and mouse down/up\n// document.addEventListener('mousedown', onMouseDown);\n// document.addEventListener('mousemove', onMouseMove);\n// document.addEventListener('mouseup', onMouseUp);\n\n// function onMouseDown(event) {\n//     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n//     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n//     // Update the raycaster\n//     raycaster.setFromCamera(mouse, camera);\n\n//     // Check for intersections\n//     const intersects = raycaster.intersectObject(cube);\n//    // console.log(\"intersects\",intersects);\n//     //isDragging = true;\n//    // previousMouseX = event.clientX;\n\n//     if (intersects.length > 0) {\n//         const selectedfaces=intersects[0].faceIndex;\n//         console.log(\"faceindex\",selectedfaces);\n//         const normal=getFaceNormals(bufferGeometry,selectedfaces)\n//         console.log(\"normals\", normal);updateNormalsAfterRotation(cube);\n\n//        controls.enabled=false;\n\n//         // Log the normal of the selected face\n\n//         isDragging = true;\n\n// }}\n\n// function onMouseMove(event) {\n//     if (isDragging) {\n//         const deltaX = event.clientX - previousMouseX;\n\n//         controls.enabled=false;\n\n//     //    normalsupdates(cube.geometry);\n\n//         // Rotate the cube around its y-axis by a small amount\n//         cube.rotation.z += deltaX * (Math.PI / 180); // Adjust this factor for sensitivity\n\n//         // Check for snapping angles (90, 180, 270 degrees)\n//         const angle = cube.rotation.z * (180 / Math.PI);\n\n//        // console.log(\"angles\",angle);\n\n//         if (angle % 90 < 5 || angle % 90 > 85) {\n//             // Snap to the nearest 90-degree angle\n//             cube.rotation.z = Math.round(angle / 90) * (Math.PI / 2);\n//            // cube.updateMatrixWorld();\n\n//            updateNormalsAfterRotation(cube);\n\n//         }\n//         controls.enabled=false;\n//         createAxesLines(cube);\n\n//         // Update previous mouse position\n//         previousMouseX = event.clientX;\n\n//     }\n\n// }\n\n// function onMouseUp() {\n\n//     isDragging = false;\n//     updateNormalsAfterRotation(cube);\n//     const yup= getFaceIndexWithNormal(cube);\n//     console.log(\"yup\",yup);\n//     controls.enabled=true;\n//     console.log(\"cube\",cube.geometry.attributes);\n//     //updateNormalsAfterRotation(cube);\n\n// }\n// Or, if the above doesn't work, try:\n// console.log(\"Cube Normals:\", cubeGeometry.attributes.normals.array);\n\nvar selectedMesh = null;\nwindow.addEventListener('resize', function (event) {\n  camera.aspect = innerWidth / innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(innerWidth, innerHeight);\n});\nwindow.addEventListener('mousedown', function (event) {\n  event.preventDefault();\n});\nvar selectedFaceIndex = null;\nvar raycaster = new THREE.Raycaster();\nvar mouse = new THREE.Vector2();\ndocument.getElementById('fileInput').addEventListener('change', handleFileSelect);\nfunction handleFileSelect(event) {\n  var file = event.target.files[0];\n  var meshes = null;\n  var geometrys = null;\n  if (file) {\n    var _loader = new https_cdn_jsdelivr_net_npm_three_0_120_1_examples_jsm_loaders_STLLoader_js__WEBPACK_IMPORTED_MODULE_0__.STLLoader();\n    _loader.load(URL.createObjectURL(file), function (geometry) {\n      var material = new THREE.MeshNormalMaterial();\n      meshes = new THREE.Mesh(geometry, material);\n      meshes.position.set(0, 0, 0);\n      scene.add(meshes);\n      geometrys = meshes.geometry;\n      if (geometrys != null) {\n        var selectedOuterFaces = selectOuterFacesAutomatically(geometrys);\n        console.log(\"Selected Outer Faces:\", selectedOuterFaces);\n        var selectedLayFlatFacesss = selectLayFlatFacesWithNormals(geometrys, selectedOuterFaces, angleSet);\n        console.log(\"Combined Selected Faces:\", selectedLayFlatFacesss);\n        var _selectedFaceIndex = 1975;\n        createPlaneFromFaces(geometrys, _selectedFaceIndex);\n      }\n      meshes.userData = {\n        file: file\n      };\n      meshes.addEventListener('click', function () {\n        if (selectedMesh) {\n          selectedMesh.material.emissive.setHex(0x000000);\n          console.log(\"slectdmesh\", selectedMesh);\n        }\n        selectedMesh = mesh;\n        mesh.material.emissive.setHex(0x00ff00);\n      });\n      fileInput.value = '';\n      console.log(\"geometrys\", geometrys);\n    });\n  }\n\n  // Handle mesh cloning\n  document.getElementById('cloneButton').addEventListener('click', function () {\n    if (selectedMesh) {\n      var clonedMesh = selectedMesh.clone();\n      clonedMesh.position.x += 2;\n      scene.add(clonedMesh);\n    }\n  });\n\n  // Handle mouse click to select face\n  // window.removeEventListener('click', onMouseClick);\n  // Add the click event listener\n  window.addEventListener('click', onMouseClick, false);\n  function onMouseClick(event) {\n    event.preventDefault();\n    mouse.x = event.clientX / window.innerWidth * 2 - 1;\n    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n    raycaster.setFromCamera(mouse, camera);\n    var intersects = raycaster.intersectObject(meshes);\n    if (intersects.length > 0) {\n      selectedFaceIndex = intersects[0].faceIndex;\n      console.log('Selected Face Index:', selectedFaceIndex);\n      //    findAllNeighboringFaces(geometrys, selectedFaceIndex);\n\n      var neigbourface = findAllNeighboringFaces(geometrys, selectedFaceIndex);\n      console.log(\"facess\", neigbourface);\n      // const singlenormal= computeAverageNormal(geometry,neigbourface);\n\n      //  console.log(\"singlenormal\",singlenormal);\n      //  const centroids = computeCentroid(geometry, neigbourface, meshes);\n      //  const averageNormal = computeAverageNormal(geometry,  neigbourface);\n      //  const planeMesh = createPlaneMesh(averageNormal, 10, 0x00ff00, centroids);\n      //  scene.add(planeMesh);\n\n      var selectedFaceNormal = getFaceNormal(geometrys, selectedFaceIndex);\n      console.log(\"gotfacenormal\", selectedFaceNormal);\n\n      //const filteredNormals = filterNormalsBySelectedFace(geometrys, selectedFaceNormal, neigbourface);\n      // console.log('Filtered Normals:', filteredNormals);\n      // highlightFilteredNormals(geometrys, selectedFaceIndex, filteredNormals);\n      var normalss = getFaceNormal(geometrys, selectedFaceIndex);\n      var angless = isAngleInSet(normalss, angleSet);\n      console.log(\"angles\", angless);\n    }\n  }\n  function createPlaneFromFaces(geometry, selectedFaceIndex) {\n    var neighbors = findAllNeighboringFaces(geometry, selectedFaceIndex);\n    console.log(\"neig\", neighbors);\n\n    // Collect vertices of neighboring faces\n    var allVertices = neighbors.map(function (neighborIndex) {\n      return getFaceVertices(geometry, neighborIndex);\n    });\n    console.log(\"allvertices\", allVertices);\n\n    // Find the boundary edges\n    var boundaryEdges = findBoundaryEdges(allVertices);\n\n    // Create a new set of vertices based on the boundary edges\n    var boundaryVertices = boundaryEdges.map(function (edge) {\n      return edge[0];\n    });\n\n    // Calculate the average position of the boundary vertices\n    var averagePosition = calculateAveragePosition(boundaryVertices);\n\n    // Choose one face to determine the normal\n    var normal = getFaceNormal(geometry, selectedFaceIndex);\n\n    // Create a plane geometry\n    var planeGeometry = new THREE.PlaneGeometry(10, 10); // Adjust the size as needed\n    var planeMaterial = new THREE.MeshBasicMaterial({\n      color: 0xffffff,\n      side: THREE.DoubleSide,\n      transparent: true,\n      opacity: 0.5\n    });\n    var planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);\n\n    // Position the plane at the average position\n    planeMesh.position.copy(averagePosition);\n    console.log(\"avragepositio\", allVertices);\n\n    // Rotate the plane based on the normal\n    var upVector = new THREE.Vector3(0, 0, 1); // or any other appropriate up vector\n    var quaternion = new THREE.Quaternion().setFromUnitVectors(upVector, normal);\n    planeMesh.setRotationFromQuaternion(quaternion);\n\n    // Add the plane to the scene\n    scene.add(planeMesh);\n  }\n  function findBoundaryEdges(neighboringVertices) {\n    var edgeMap = new Map();\n\n    // Function to add an edge to the map\n    var addEdgeToMap = function addEdgeToMap(vertex1, vertex2) {\n      var key = vertex1 < vertex2 ? \"\".concat(vertex1, \"_\").concat(vertex2) : \"\".concat(vertex2, \"_\").concat(vertex1);\n      if (!edgeMap.has(key)) {\n        edgeMap.set(key, [vertex1, vertex2]);\n      } else {\n        edgeMap[\"delete\"](key); // Remove the edge if it is shared by more than one face\n      }\n    };\n\n    // Function to process each face's edges\n    var processFaceEdges = function processFaceEdges(faceVertices) {\n      for (var i = 0; i < faceVertices.length; i++) {\n        var vertex1 = faceVertices[i];\n        var vertex2 = faceVertices[(i + 1) % faceVertices.length];\n        addEdgeToMap(vertex1, vertex2);\n      }\n    };\n\n    // Process each face's edges\n    var _iterator = _createForOfIteratorHelper(neighboringVertices),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var faceVertices = _step.value;\n        processFaceEdges(faceVertices);\n      }\n\n      // Return the remaining edges as boundary edges\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return Array.from(edgeMap.values());\n  }\n\n  // Example usage:\n  function calculateAveragePosition(vertices) {\n    if (vertices.length === 0) {\n      return new THREE.Vector3(); // Return the origin if there are no vertices\n    }\n    var sum = vertices.reduce(function (accumulator, currentVertex) {\n      accumulator.x += currentVertex.x;\n      accumulator.y += currentVertex.y;\n      accumulator.z += currentVertex.z;\n      return accumulator;\n    }, new THREE.Vector3());\n    var count = vertices.length;\n    var average = new THREE.Vector3(sum.x / count, sum.y / count, sum.z / count);\n    return average;\n  }\n  function computeCentroid(geometrys, faceIndices, mesh) {\n    var centroids = faceIndices.map(function (faceIndex) {\n      var position = getFacePositions(geometrys, faceIndex, mesh);\n      var normal = getFaceNormal(geometry, faceIndex);\n\n      // Log for debugging\n      //console.log(`Face Index: ${faceIndex}, Position: ${JSON.stringify(position)}, Normal: ${JSON.stringify(normal)}`);\n\n      return position;\n    });\n    var centroid = new THREE.Vector3();\n    centroids.forEach(function (point) {\n      return centroid.add(point);\n    });\n    centroid.divideScalar(centroids.length);\n\n    // Log for debugging\n    //    console.log(`Final Centroid: ${JSON.stringify(centroid)}`);\n\n    return centroid;\n  }\n  function createPlaneMesh(normal, size, color, centroids) {\n    // Check if centroids array is empty\n    if (centroids.length === 0) {\n      console.error('Centroids array is empty');\n      return null; // Or handle the error in an appropriate way\n    }\n\n    // Remove undefined elements from centroids array\n    var validCentroids = centroids.filter(function (centroid) {\n      return centroid !== undefined;\n    });\n\n    // Check if there are valid centroids after filtering\n    if (validCentroids.length === 0) {\n      console.error('No valid centroids in the array');\n      return null; // Or handle the error in an appropriate way\n    }\n\n    // Calculate the average centroid\n    var averageCentroid = validCentroids.reduce(function (sum, centroid) {\n      return sum.add(centroid);\n    }, new THREE.Vector3()).divideScalar(validCentroids.length);\n\n    // Create a plane geometry\n    var planeGeometry = new THREE.PlaneGeometry(size, size);\n\n    // Create a material\n    var planeMaterial = new THREE.MeshBasicMaterial({\n      color: color,\n      side: THREE.DoubleSide\n    });\n\n    // Create the plane mesh\n    var planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);\n\n    // Set the position of the plane based on the average centroid\n    planeMesh.position.copy(averageCentroid);\n\n    // Align the plane with the average normal\n    var up = new THREE.Vector3(0, 1, 0); // or any other vector not parallel to the normal\n    var quaternion = new THREE.Quaternion().setFromUnitVectors(up, normal.clone().normalize());\n    planeMesh.quaternion.copy(quaternion);\n    return planeMesh;\n  }\n  function computeAverageNormal(geometry, faceIndices) {\n    var normal = new THREE.Vector3();\n    var _iterator2 = _createForOfIteratorHelper(faceIndices),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _faceIndex = _step2.value;\n        var _faceNormal = getFaceNormal(geometry, _faceIndex);\n        normal.add(_faceNormal);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    normal.divideScalar(faceIndices.length).normalize();\n    return normal;\n  }\n  function findAllNeighboringFaces(geometry, selectedFaceIndex) {\n    var faces = geometry.attributes.position.count / 3;\n    var neighbors = [];\n    var selectedVertices = getFaceVertices(geometry, selectedFaceIndex);\n    for (var i = 0; i < faces; i++) {\n      if (i !== selectedFaceIndex) {\n        var vertices = getFaceVertices(geometry, i);\n        if (areVerticesInSamePlane(selectedVertices, vertices)) {\n          neighbors.push(i);\n        }\n      }\n    }\n\n    // console.log(\"neighbours\", neighbors);\n    return neighbors;\n  }\n  var isDragging = false;\n  var isrotating = false;\n\n  // Offset between intersection point and click position\n  var dragOffset = new THREE.Vector3();\n  var isRotationEventAttached = false;\n  document.getElementById('rotationButton').addEventListener('click', function () {\n    if (!isRotationEventAttached) {\n      document.addEventListener('mousedown', onMouseDown);\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', onMouseUp);\n      isRotationEventAttached = true;\n    } else {\n      document.removeEventListener('mousedown', onMouseDown);\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n      isRotationEventAttached = false;\n    }\n  });\n  var previousMousePosition = {\n    x: 0,\n    y: 0\n  };\n  // Disable OrbitControls on mousedown if ray intersects the mesh\n  function onMouseDown(event) {\n    event.preventDefault();\n\n    // Set mouse coordinates\n    mouse.x = event.clientX / window.innerWidth * 2 - 1;\n    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n    // Update the raycaster\n    raycaster.setFromCamera(mouse, camera);\n\n    // Check for intersections\n    var intersects = raycaster.intersectObject(meshes);\n    if (intersects.length > 0) {\n      isrotating = true;\n      isDragging = false;\n\n      // Calculate the offset between intersection point and click position\n      dragOffset.copy(intersects[0].point).sub(meshes.position);\n\n      // Disable OrbitControls\n      controls.enabled = false;\n    }\n  }\n\n  // Move the mesh on mousemove if dragging\n  function onMouseMove(event) {\n    event.preventDefault();\n    if (isrotating) {\n      // Update the mouse coordinates\n      var currentMousePosition = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      var deltaX = currentMousePosition.x - previousMousePosition.x;\n\n      // Step 4: Apply Rotation\n      meshes.rotation.y += deltaX * 0.01;\n      meshes.verticesNeedUpdate = true;\n      meshes.normalsNeedUpdate = true;\n      meshes.updateMatrixWorld();\n      var _transformationMatrixss = new THREE.Matrix4().copy(meshes.matrix);\n      console.log(\"mesh matrix\", _transformationMatrixss);\n\n      // Update previous mouse position\n      previousMousePosition = currentMousePosition;\n    }\n  }\n\n  // Enable OrbitControls on mouseup\n  function onMouseUp() {\n    isrotating = false;\n    meshes.verticesNeedUpdate = true;\n    meshes.normalsNeedUpdate = true;\n    meshes.updateMatrixWorld();\n\n    // Enable OrbitControls\n    controls.enabled = true;\n  }\n  document.addEventListener('mousedown', onobject);\n  document.addEventListener('mousemove', onobjectmove);\n  document.addEventListener('mouseup', onup);\n  function onobject(event) {\n    event.preventDefault();\n\n    // Set mouse coordinates\n    mouse.x = event.clientX / window.innerWidth * 2 - 1;\n    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n    // Update the raycaster\n    raycaster.setFromCamera(mouse, camera);\n\n    // Check for intersections\n    var intersects = raycaster.intersectObject(meshes);\n    if (intersects.length > 0) {\n      isDragging = true;\n\n      // Calculate the offset between intersection point and click position\n      dragOffset.copy(intersects[0].point).sub(meshes.position);\n\n      // Disable OrbitControls\n      controls.enabled = false;\n    }\n  }\n\n  // Move the mesh on mousemove if dragging\n  function onobjectmove(event) {\n    event.preventDefault();\n    if (isDragging) {\n      // Update the mouse coordinates\n      mouse.x = event.clientX / window.innerWidth * 2 - 1;\n      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n      // Update the raycaster\n      raycaster.setFromCamera(mouse, camera);\n\n      // Raycast to find the intersection point\n      var intersects = raycaster.intersectObject(meshes);\n      if (intersects.length > 0) {\n        // Update only the X and Z components of the mesh's position\n        meshes.position.x = intersects[0].point.x - dragOffset.x;\n        meshes.position.z = intersects[0].point.z - dragOffset.z;\n        meshes.verticesNeedUpdate = true;\n        meshes.normalsNeedUpdate = true;\n        meshes.updateMatrixWorld();\n      }\n    }\n  }\n\n  // Enable OrbitControls on mouseup\n  function onup() {\n    isDragging = false;\n    meshes.verticesNeedUpdate = true;\n    meshes.normalsNeedUpdate = true;\n    meshes.updateMatrixWorld();\n\n    // Enable OrbitControls\n    controls.enabled = true;\n  }\n\n  //  highlightFilteredNormals(geometry, 33, neigbourfacesss  );\n\n  function areVerticesInSamePlane(vertices1, vertices2) {\n    var threshold = 0.001; // Adjust the threshold based on your model\n    var plane = new THREE.Plane().setFromCoplanarPoints(vertices1[0], vertices1[1], vertices1[2]);\n    return vertices2.every(function (vertex) {\n      return Math.abs(plane.distanceToPoint(vertex)) < threshold;\n    });\n  }\n\n  // Function to get the vertices of a face\n  function getFaceVertices(geometry, faceIndex) {\n    var positions = geometry.attributes.position.array;\n    var startIndex = faceIndex * 9;\n    return [new THREE.Vector3(positions[startIndex], positions[startIndex + 1], positions[startIndex + 2]), new THREE.Vector3(positions[startIndex + 3], positions[startIndex + 4], positions[startIndex + 5]), new THREE.Vector3(positions[startIndex + 6], positions[startIndex + 7], positions[startIndex + 8])];\n  }\n  var mergedPositions = [];\n  var mergedMesh = null;\n  var mergedarraynormals = [];\n  var mergedarray = [];\n  function highlightFilteredNormals(geometry, selectedFaceIndex, filteredNormals) {\n    var positions = geometry.attributes.position.array;\n    var normals = geometry.attributes.normal.array;\n    var mergedNormals = [];\n    // createAxesLines(meshes);\n\n    // Add the selected face to the merged geometry\n    var selectedFaceStart = selectedFaceIndex * 9;\n    var selectedFaceEnd = selectedFaceStart + 9;\n    mergedPositions.push.apply(mergedPositions, _toConsumableArray(positions.slice(selectedFaceStart, selectedFaceEnd)));\n    mergedNormals.push.apply(mergedNormals, _toConsumableArray(normals.slice(selectedFaceStart, selectedFaceEnd)));\n\n    // Extract positions and normals of selected and filtered neighboring faces\n    filteredNormals.forEach(function (faceIndex) {\n      var startIndex = faceIndex * 9;\n      var endIndex = startIndex + 9;\n      var facePositions = positions.slice(startIndex, endIndex);\n      var faceNormals = normals.slice(startIndex, endIndex);\n      if (!containsNaN(facePositions) && !containsNaN(faceNormals)) {\n        mergedPositions.push.apply(mergedPositions, _toConsumableArray(facePositions));\n        mergedNormals.push.apply(mergedNormals, _toConsumableArray(faceNormals));\n      }\n    });\n\n    // Create a new BufferGeometry for the merged faces\n    var mergedGeometry = new THREE.BufferGeometry();\n    mergedGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(mergedPositions), 3));\n    mergedGeometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(mergedNormals), 3));\n\n    // Calculate a single normal for the merged faces\n\n    // Create a mesh with the merged geometry\n    var mergedMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      wireframe: true\n    });\n    mergedMesh = new THREE.Mesh(mergedGeometry, mergedMaterial);\n\n    // Add the merged mesh to the scene\n    scene.add(mergedMesh);\n    mergedarray.push(mergedMesh);\n    mergedarraynormals.push(mergedNormals);\n    var maxLength = 0;\n    var longestMeshIndex = -1;\n    for (var i = 0; i < mergedarray.length; i++) {\n      var normalsArray = mergedarray[i].geometry.getAttribute('normal').array;\n      //  console.log(`Normals for Mesh ${i + 1}:`, normalsArray.length);\n      var normils = normalsArray[i];\n      //  console.log(\"normils\", normils);\n      normalSum = new THREE.Vector3(); // Initialize outside the loop to accumulate all normals\n\n      for (var _i = 0; _i < mergedarray.length; _i++) {\n        var _normalsArray = mergedarray[_i].geometry.getAttribute('normal').array;\n        // console.log(`Normals for Mesh ${i + 1}:`, normalsArray.length);\n\n        // Sum up all normals\n        for (var j = 0; j < _normalsArray.length; j += 3) {\n          var normal = new THREE.Vector3(_normalsArray[j], _normalsArray[j + 1], _normalsArray[j + 2]);\n          normalSum.add(normal);\n        }\n        if (_normalsArray.length > maxLength) {\n          maxLength = _normalsArray.length;\n          longestMeshIndex = _i;\n        }\n      }\n\n      // console.log(`Mesh with the longest normals is at index ${longestMeshIndex} with length ${maxLength}`);\n\n      // Normalize the sum to get the average normal\n      normalSum.normalize();\n      //console.log(\"Combined Face Normal:\", normalSum);\n    }\n  }\n  var normalSum = null;\n  var isMouseDownEventAttached = false;\n  document.getElementById('layflat').addEventListener('click', function () {\n    if (!isMouseDownEventAttached) {\n      document.addEventListener('mousedown', onMouseClicksss, false);\n      isMouseDownEventAttached = true;\n    } else {\n      document.removeEventListener('mousedown', onMouseClicksss, false);\n      isMouseDownEventAttached = false;\n    }\n  });\n  // const neigbourfacesss = findAllNeighboringFaces(geometry, 58);\n  //    console.log(\"negia\",neigbourfacesss);\n\n  function calculateMeshDimensions(mesh) {\n    var geometry = mesh.geometry;\n    var positions = geometry.attributes.position.array;\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    for (var i = 0; i < positions.length; i += 3) {\n      var x = positions[i];\n      var y = positions[i + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n    var length = maxX - minX;\n    var width = maxY - minY;\n    return {\n      length: length,\n      width: width\n    };\n  }\n\n  // Helper function to check for NaN values in an array\n  function containsNaN(array) {\n    for (var i = 0; i < array.length; i++) {\n      if (isNaN(array[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function mergeMeshesIntoSingleMesh(meshes) {\n    var mergedGeometry = new THREE.BufferGeometry();\n    var mergedMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      wireframe: true\n    });\n    var mergedPositions = [];\n    var mergedNormals = [];\n    meshes.forEach(function (mesh) {\n      var positions = mesh.geometry.getAttribute('position').array;\n      var normals = mesh.geometry.getAttribute('normal').array;\n      mergedPositions.push.apply(mergedPositions, _toConsumableArray(positions));\n      mergedNormals.push.apply(mergedNormals, _toConsumableArray(normals));\n    });\n    mergedGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(mergedPositions), 3));\n    mergedGeometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(mergedNormals), 3));\n\n    // Create a mesh with the merged geometry and material\n    var mergedMesh = new THREE.Mesh(mergedGeometry, mergedMaterial);\n    return mergedMesh;\n  }\n  function getFaceNormal(geometry, faceIndex) {\n    var normals = geometry.attributes.normal.array;\n    var startIndex = faceIndex * 9;\n    return new THREE.Vector3(normals[startIndex], normals[startIndex + 1], normals[startIndex + 2]);\n  }\n\n  // Function to filter neighboring faces based on normals using dot product\n  function filterNormalsBySelectedFace(geometry, selectedFaceNormal, neighboringFaces) {\n    return neighboringFaces.filter(function (neighboringFaceIndex) {\n      var neighboringFaceNormal = getFaceNormal(geometry, neighboringFaceIndex);\n      // Normalize the vectors before computing the dot product\n      selectedFaceNormal.normalize();\n      neighboringFaceNormal.normalize();\n      // Compare normals using the dot product\n      var dotProduct = selectedFaceNormal.dot(neighboringFaceNormal);\n      // You can adjust the threshold based on your requirements\n      var threshold = 0.999; // Cosine of a small angle (e.g., 2 degrees)\n      return dotProduct > threshold;\n    });\n  }\n  function getFaceVerticess(geometry, faceIndex) {\n    var vertices = [];\n    if (geometry instanceof THREE.BufferGeometry) {\n      // Handle BufferGeometry\n      var positions = geometry.attributes.position.array;\n      var startIndex = faceIndex * 9;\n      for (var i = 0; i < 9; i += 3) {\n        vertices.push(new THREE.Vector3(positions[startIndex + i], positions[startIndex + i + 1], positions[startIndex + i + 2]));\n      }\n    } else if (geometry instanceof THREE.Geometry) {\n      // Handle Geometry (deprecated in newer Three.js versions)\n      var face = geometry.faces[faceIndex];\n      var verticesIndices = [face.a, face.b, face.c];\n      verticesIndices.forEach(function (index) {\n        var vertex = geometry.vertices[index];\n        vertices.push(new THREE.Vector3(vertex.x, vertex.y, vertex.z));\n      });\n    } else {\n      // Handle other geometry types as needed\n      // You might need additional checks for different geometry types\n    }\n    return vertices;\n  }\n  var transformationMatrixss = null;\n  function onMouseClicksss(event) {\n    event.preventDefault();\n    mouse.x = event.clientX / window.innerWidth * 2 - 1;\n    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n    raycaster.setFromCamera(mouse, camera);\n    var intersects = raycaster.intersectObject(meshes);\n    if (intersects.length > 0) {\n      selectedFaceIndex = intersects[0].faceIndex;\n      console.log('Selected Face Index:', selectedFaceIndex);\n      var beforroation = getFacePositions(geometrys, selectedFaceIndex, meshes);\n      console.log(\"beforerotationface\", beforroation);\n      meshes.rotation.set(0, 0, 0);\n      var selectedFaceNormals = getFaceNormal(geometrys, selectedFaceIndex);\n      console.log('Selected Face Normals:', selectedFaceNormals);\n      //const   angles = isAngleInSet( selectedFaceNormals, angleSet)\n      // console.log(\"angless\",angles);\n      // singlemeshes.updateMatrixWorld();\n      //  let boxmatrixss=planes.matrix.identity();\n      // console.log(\"boxesmatrixss\",boxmatrixss);\n      var rotationMatrix = calculateRotationMatrix(selectedFaceNormals, constantPlaneNormal);\n      var _transformationMatrixss2 = new THREE.Matrix4().copy(meshes.matrix);\n      console.log(\"mesh matrix\", _transformationMatrixss2);\n\n      //console.log(\"singlmesh\".singlemesh);\n\n      // Multiply the mesh matrix with the rotation matrix\n      var combinedMatrix = new THREE.Matrix4().multiplyMatrices(_transformationMatrixss2, rotationMatrix);\n      // Apply the new rotation to the existing matrix\n\n      geometrys.applyMatrix4(combinedMatrix);\n      meshes.updateMatrixWorld();\n      var afeterrotation = getFacePositions(geometrys, selectedFaceIndex, meshes);\n      geometrys.normalsNeedUpdate = true;\n      _transformationMatrixss2 = new THREE.Matrix4().copy(meshes.matrix);\n      console.log(\"afterrotationmatrix\", _transformationMatrixss2);\n      var transformation = calculateTransformationMatrixs(selectedFaceIndex, plane, meshes, afeterrotation);\n      var combinedMatrixs = new THREE.Matrix4().multiplyMatrices(_transformationMatrixss2, transformation);\n      geometrys.applyMatrix4(combinedMatrixs);\n      meshes.verticesNeedUpdate = true;\n      meshes.normalsNeedUpdate = true;\n      meshes.updateMatrixWorld();\n      //geometrys.updateMatrixWorld();\n      _transformationMatrixss2 = new THREE.Matrix4().copy(meshes.matrix);\n    }\n  }\n  var xAxisLine, yAxisLine, zAxisLine;\n  function createAxesLines(mesh) {\n    // Extract the columns of the mesh matrix (local coordinate axes)\n    var xAxis = new THREE.Vector3().fromArray(mesh.matrix.elements.slice(0, 3));\n    var yAxis = new THREE.Vector3().fromArray(mesh.matrix.elements.slice(4, 7));\n    var zAxis = new THREE.Vector3().fromArray(mesh.matrix.elements.slice(8, 11));\n\n    // Remove existing lines if they exist\n    if (xAxisLine) scene.remove(xAxisLine);\n    if (yAxisLine) scene.remove(yAxisLine);\n    if (zAxisLine) scene.remove(zAxisLine);\n\n    // Create lines along the local coordinate axes\n    xAxisLine = new THREE.ArrowHelper(xAxis, mesh.position, 10, 0xff0000);\n    yAxisLine = new THREE.ArrowHelper(yAxis, mesh.position, 10, 0x00ff00);\n    zAxisLine = new THREE.ArrowHelper(zAxis, mesh.position, 10, 0x0000ff);\n\n    // Add the lines to the scene\n    scene.add(xAxisLine);\n    scene.add(yAxisLine);\n    scene.add(zAxisLine);\n  }\n  function calculateTransformationMatrixs(faceIndex, planeMesh, mesh, facePosition) {\n    // Ensure geometry is updated\n    mesh.geometry.computeBoundingBox();\n    mesh.updateMatrixWorld();\n    var planeNormal = planeMesh.geometry.faces[0].normal.clone().applyQuaternion(planeMesh.quaternion);\n    var planePosition = planeMesh.position;\n\n    // Calculate the vector from the face position to a point on the plane\n    var vectorToPlane = new THREE.Vector3().subVectors(facePosition, planePosition);\n\n    // Project the vector onto the plane's normal to find the distance to the plane\n    var distanceToPlane = vectorToPlane.dot(planeNormal) * 2;\n    console.log(\"distanceto the plane\", distanceToPlane);\n\n    // Get the vertices of the selected face\n    var faceVertices = getFaceVertices(mesh.geometry, faceIndex);\n\n    // Calculate the center of the face\n    var faceCenter = new THREE.Vector3();\n    faceVertices.forEach(function (vertex) {\n      return faceCenter.add(vertex);\n    });\n    faceCenter.divideScalar(faceVertices.length);\n\n    // Create a translation matrix to move the object's origin to the face center and then move up to the top of the plane\n    var translationMatrix = new THREE.Matrix4().makeTranslation(-faceCenter.x, faceCenter.y + distanceToPlane, -faceCenter.z);\n    return translationMatrix;\n  }\n  function getFacePositions(geometry, faceIndex, mesh) {\n    var positions = geometry.attributes.position.array;\n    var startIndex = faceIndex * 3 * 3;\n\n    // Calculate the average position of the vertices to get the face position in local coordinates\n    var localPosition = new THREE.Vector3();\n    for (var i = 0; i < 3; i++) {\n      var index = startIndex + i * 3;\n      var x = positions[index];\n      var y = positions[index + 1];\n      var z = positions[index + 2];\n      localPosition.add(new THREE.Vector3(x, y, z));\n    }\n    localPosition.divideScalar(3);\n    //console.log(\"local\",localPosition);\n\n    // Convert the local face position to global coordinates by applying the mesh's matrixWorld\n    var globalPosition = localPosition.clone().applyMatrix4(mesh.matrixWorld);\n    //   console.log(\"meshworld\",mesh.matrixWorld);\n\n    return globalPosition;\n  }\n  function selectOuterFacesAutomatically(geometry) {\n    var faces = geometry.attributes.position.count / 3;\n    var selectedFaces = new Set();\n    var excludedFaces = new Set();\n    var processFace = function processFace(faceIndex) {\n      if (!excludedFaces.has(faceIndex)) {\n        var neighbors = findAllNeighboringFaces(geometry, faceIndex);\n        neighbors.forEach(function (neighborIndex) {\n          excludedFaces.add(neighborIndex); // Exclude neighbors from future iterations\n        });\n        var normal = getFaceNormal(geometry, faceIndex);\n        var thresholdMin = 0.2; // Adjust this threshold based on your requirements\n        var thresholdMax = 1;\n\n        // Check if the absolute values are within the range [0.9, 1.1]\n        if (Math.abs(normal.x) >= thresholdMin && Math.abs(normal.x) <= thresholdMax || Math.abs(normal.y) >= thresholdMin && Math.abs(normal.y) <= thresholdMax || Math.abs(normal.z) >= thresholdMin && Math.abs(normal.z) <= thresholdMax) {\n          selectedFaces.add(faceIndex);\n        }\n        neighbors.forEach(processFace); // Recursively process neighbors\n      }\n    };\n\n    // Start processing faces from the beginning\n    for (var i = 0; i < faces; i++) {\n      processFace(i);\n    }\n    return Array.from(selectedFaces);\n  }\n  function selectLayFlatFacesWithNormals(geometry, selectedOuterFaces, angleSet) {\n    var flatfaces = {};\n    selectedOuterFaces.forEach(function (selectedFaceIndex) {\n      var selectedFaceNormal = getFaceNormal(geometry, selectedFaceIndex);\n\n      // Check if the face normal is within the specified angle set\n      var result = isAngleInSet(selectedFaceNormal, angleSet);\n      if (result.isInSet) {\n        var angles = result.angle;\n        var direction = getDirectionLabel(selectedFaceNormal);\n\n        // Initialize the angles entry if it doesn't exist\n        if (!flatfaces[angles]) {\n          flatfaces[angles] = {};\n        }\n\n        // Initialize the direction entry if it doesn't exist\n        if (!flatfaces[angles][direction]) {\n          flatfaces[angles][direction] = {\n            normals: [],\n            faceIndices: []\n          };\n        }\n\n        // Add the current normal and face index to the direction entry\n        flatfaces[angles][direction].normals.push(selectedFaceNormal);\n        flatfaces[angles][direction].faceIndices.push(selectedFaceIndex);\n      }\n    });\n    return flatfaces;\n  }\n  function getDirectionLabel(normal) {\n    var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.99;\n    var thresholdmin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.2;\n    var thresholdMax = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.9;\n    var epsilon = 1e-6; // A small value to handle rounding errors\n\n    if (normal.x > threshold) {\n      return 'x';\n    } else if (normal.x < -threshold) {\n      return '-x';\n    } else if (normal.y > threshold) {\n      return 'y';\n    } else if (normal.y < -threshold) {\n      return '-y';\n    } else if (normal.z > threshold) {\n      return 'z';\n    } else if (normal.z < -threshold) {\n      return '-z';\n    } else if (Math.abs(normal.x) < epsilon && Math.abs(normal.y) < epsilon) {\n      return 'z'; // xy plane\n    } else if (Math.abs(normal.x) < epsilon && Math.abs(normal.z) < epsilon) {\n      return 'y'; // xz plane\n    } else if (Math.abs(normal.y) < epsilon && Math.abs(normal.z) < epsilon) {\n      return 'x'; // yz plane\n    } else if (Math.abs(normal.x) < epsilon && Math.abs(normal.y) < threshold && Math.abs(normal.z) < threshold) {\n      return 'xy'; // plane between x and y\n    } else if (Math.abs(normal.x) < threshold && Math.abs(normal.y) < epsilon && Math.abs(normal.z) < threshold) {\n      return 'xz'; // plane between x and z\n    } else if (Math.abs(normal.x) < threshold && Math.abs(normal.y) < threshold && Math.abs(normal.z) < epsilon) {\n      return 'yz'; // plane between y and z\n    } else if (Math.abs(normal.x) >= thresholdmin && Math.abs(normal.x) <= thresholdMax, Math.abs(normal.y) >= thresholdmin && Math.abs(normal.y) <= thresholdMax, Math.abs(normal.y) >= thresholdmin && Math.abs(normal.y) <= thresholdMax) {\n      return 'xyz'; // Zero in all directions\n    } else {\n      return 'unknown';\n    }\n  }\n  var epsilon = 1e-6; // A small value to handle rounding errors\n  function isAngleInSet(normal, angleSet) {\n    // Ensure the normal vector is normalized\n    var length = Math.sqrt(Math.pow(normal.x, 2) + Math.pow(normal.y, 2) + Math.pow(normal.z, 2));\n    var normalizedNormal = {\n      x: normal.x / length,\n      y: normal.y / length,\n      z: normal.z / length\n    };\n\n    // Calculate the angle in radians using atan2, considering all three components\n    var angle = Math.atan2(normalizedNormal.y, normalizedNormal.x, normalizedNormal.z);\n\n    // Convert the angle to degrees and ensure it's within [0, 360] degrees\n    var degrees = angle * 180 / Math.PI;\n    degrees = (degrees + 360) % 360;\n    // console.log(\"degree\",degrees);\n\n    // Adjust for negative angles\n    if (degrees < 0) {\n      degrees += 360;\n    }\n\n    // Round the angle to the nearest integer\n    degrees = Math.round(degrees);\n    var isInSet = angleSet.includes(degrees);\n    return {\n      angle: degrees,\n      isInSet: isInSet\n    };\n  }\n  var angleSet = [0, 45, 90, 70, 135, 180, 225, 270, 360, 315];\n  function findFarthestFaces(selectedFacesWithNormals, geometry, mesh) {\n    var farthestFaces = {};\n    for (var direction in selectedFacesWithNormals) {\n      if (Object.hasOwnProperty.call(selectedFacesWithNormals, direction)) {\n        var directionData = selectedFacesWithNormals[direction];\n        var positiveDistance = -Infinity;\n        var negativeDistance = Infinity;\n        var farthestPositiveFace = null;\n        var farthestNegativeFace = null;\n        for (var i = 0; i < directionData.faceIndices.length; i++) {\n          var _faceIndex2 = directionData.faceIndices[i];\n          var facePosition = getFacePositions(geometry, _faceIndex2, mesh);\n          var distance = void 0;\n          switch (direction) {\n            case 'x':\n            case '-x':\n              distance = facePosition.x;\n              break;\n            case 'y':\n            case '-y':\n              distance = facePosition.y;\n              break;\n            case 'z':\n            case '-z':\n              distance = facePosition.z;\n              break;\n            case 'xy':\n              distance = Math.sqrt(Math.pow(facePosition.x, 2) + Math.pow(facePosition.y, 2));\n              break;\n            case 'xz':\n              distance = Math.sqrt(Math.pow(facePosition.x, 2) + Math.pow(facePosition.z, 2));\n              break;\n            case 'yz':\n              distance = Math.sqrt(Math.pow(facePosition.y, 2) + Math.pow(facePosition.z, 2));\n              break;\n            // Add more cases for other directions as needed\n          }\n\n          // Update the farthest face for positive and negative distances\n          if (distance !== undefined) {\n            if (distance > positiveDistance) {\n              positiveDistance = distance;\n              farthestPositiveFace = _faceIndex2;\n            }\n            if (distance < negativeDistance) {\n              negativeDistance = distance;\n              farthestNegativeFace = _faceIndex2;\n            }\n          }\n        }\n\n        // Determine the overall farthest face based on the maximum absolute distance\n        if (Math.abs(positiveDistance) > Math.abs(negativeDistance)) {\n          farthestFaces[direction] = farthestPositiveFace;\n        } else {\n          farthestFaces[direction] = farthestNegativeFace;\n        }\n      }\n    }\n    return farthestFaces;\n  }\n\n  //const farthestFaces = findFarthestFaces(selectedLayFlatFacesss, geometry,meshes);\n\n  //console.log(\"Farthest Faces:\", farthestFaces);\n\n  var singlemeshes = null;\n  var negibourefaces = [];\n  function selectedNeighbours(farthestFaces, geometry) {\n    for (var direction in farthestFaces) {\n      if (Object.hasOwnProperty.call(farthestFaces, direction)) {\n        var farthestFaceIndex = farthestFaces[direction];\n        var neighbors = findAllNeighboringFaces(geometry, farthestFaceIndex);\n        //const farthestFaceNormal = getFaceNormal(geometry, farthestFaceIndex);\n        highlightFilteredNormals(geometry, farthestFaceIndex, neighbors);\n      }\n    }\n    singlemeshes = mergeMeshesIntoSingleMesh(mergedarray);\n    scene.add(singlemeshes);\n    singlemeshes.position.copy(meshes.position);\n    singlemeshes.quaternion.copy(meshes.quaternion);\n  }\n  //console.log(\"mesd\",singlemeshes);\n  //selectedNeighbours(farthestFaces, geometry);\n  function getFacePosition(geometry, faceIndex) {\n    var vertices = getFaceVertices(geometry, faceIndex);\n\n    // Calculate the average position of the vertices to get the face position\n    var position = {\n      x: (vertices[0].x + vertices[1].x + vertices[2].x) / 3,\n      y: (vertices[0].y + vertices[1].y + vertices[2].y) / 3,\n      z: (vertices[0].z + vertices[1].z + vertices[2].z) / 3\n    };\n    return position;\n  }\n  function getFaceNormals(geometry, faceIndex) {\n    var normal = new THREE.Vector3();\n\n    // Get the vertices of the face\n    var vertices = getFaceVerticess(geometry, faceIndex);\n    console.log(vertices);\n    if (vertices.length >= 3) {\n      // Calculate the face normal using the cross product of two edges\n      var edge1 = new THREE.Vector3().subVectors(vertices[1], vertices[0]);\n      var edge2 = new THREE.Vector3().subVectors(vertices[2], vertices[0]);\n\n      // Ensure the vertices form a valid face (at least three vertices)\n      normal.crossVectors(edge1, edge2).normalize();\n    }\n    return normal;\n  }\n\n  // Replace with your constant plane normal\n\n  function calculateRotationMatrix(selectedFaceNormal, constantPlaneNormal) {\n    var axis = new THREE.Vector3().crossVectors(selectedFaceNormal, constantPlaneNormal).normalize();\n    console.log(\" axis\", axis);\n    var angle = Math.acos(selectedFaceNormal.dot(constantPlaneNormal) / (selectedFaceNormal.length() * constantPlaneNormal.length()));\n\n    // Ensure axis is consistently pointing away from the constant plane normal\n\n    var rotationMatrix = new THREE.Matrix4();\n    rotationMatrix.makeRotationAxis(axis, angle);\n    return rotationMatrix;\n  }\n}\nfunction animate() {\n  requestAnimationFrame(animate);\n  controls.update();\n  renderer.render(scene, camera);\n}\nanimate();\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack:///./main.js?");

/***/ }),

/***/ "https://cdn.jsdelivr.net/npm/three@0.120.1/examples/jsm/loaders/STLLoader.js":
false

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./main.js");
/******/ 	
/******/ })()
;